---
title: "Expansion planning report"
output: html_document
---

This file has been generated by the package antaresXpansion.
It gives an overview of the results of the investment optimisation problem solved by the package.


```{r, include = FALSE}
## load packages
library(plotly)
library(magrittr)
library(dplyr)
library(data.table)
library(knitr)
library(shiny)
```

# General information

Study :
```{r print_study_name, echo=FALSE, eval=TRUE}
cat(x$study_options$studyPath)
```

Date :
```{r print_date, echo=FALSE, eval=TRUE}
lubridate::now()
```

Expansion planning options :
```{r print_exp_options, echo=FALSE, eval=TRUE}
option_names <- names(x$expansion_options)
for(i in 1:length(option_names))
{
  cat("   - ", option_names[i], " : ", x$expansion_options[[i]], "\n")
}

```

Package version :
```{r print_package_version, echo=FALSE, eval=TRUE}
packageVersion("antaresXpansion")
```

# Best found solution

```{r get_best_cost, echo = FALSE, eval = TRUE}

best_solutions <- x$costs[which(x$costs$overall_costs == min(x$costs$overall_costs, na.rm = TRUE)),"it"]
sol_id <- paste0("it", best_solutions)

n_best_solution <- length(best_solutions)
n_iteration <- max(x$costs$it)
```


Total cost : 
```{r print_total_cost, echo=FALSE, eval = TRUE}
cat(subset(x$costs, it == best_solutions[1])$overall_costs, "euros\n")
cat(subset(x$costs, it == best_solutions[1])$overall_costs/10^6, "million euros\n")

if(n_best_solution > 1)
{
  cat("There is", n_best_solution, "equivalent solutions leading to this cost")
}

```

Investment cost :
```{r print_inv_cost, echo=FALSE, eval = TRUE}
if(n_best_solution == 1)
{
  cat(subset(x$costs, it == best_solutions[1])$investment_costs, "euros\n")
  cat(subset(x$costs, it == best_solutions[1])$investment_costs/10^6, "million euros\n")
}
if(n_best_solution > 1)
{
  for(i in 1:n_best_solution)
  {
    cat("solution", i, ":\n")
    cat("   -",subset(x$costs, it == best_solutions[i])$investment_costs, "euros\n")
    cat("   -",subset(x$costs, it == best_solutions[i])$investment_costs/10^6, "million euros\n") 
  }
}

```

Production cost :
```{r print_prod_cost, echo=FALSE, eval = TRUE}
if(n_best_solution == 1)
{
  cat(subset(x$costs, it == best_solutions[1])$operation_costs, "euros\n")
  cat(subset(x$costs, it == best_solutions[1])$operation_costs/10^6, "million euros\n")
}
if(n_best_solution > 1)
{
  for(i in 1:n_best_solution)
  {
    cat("solution", i, ":\n")
    cat("   -",subset(x$costs, it == best_solutions[i])$operation_costs, "euros\n")
    cat("   -",subset(x$costs, it == best_solutions[i])$operation_costs/10^6, "million euros\n") 
  }
}
```


Invested capacities (in MW):
```{r print_invested_cap, echo=FALSE, eval = TRUE, results="asis"}
kable(subset(x$invested_capacities, it %in% best_solutions), format = "markdown")
```


# Convergence

Number of iterations :
```{r print_number_of_iterations, echo=FALSE, eval = TRUE}
cat(n_iteration)
```

Number of simulated weeks :
```{r print_number_of_simulated_weeks, echo=FALSE, eval = TRUE}

n_weeks <- sum(sapply(1:n_iteration, FUN = function(i){length(x$iterations[[i]]$weeks) * length(x$iterations[[i]]$mc_years)}))

cat(n_weeks)
```


Iteration with the (first) best solution :
```{r print_iteration_best, echo=FALSE, eval = TRUE}
cat(min(best_solutions))
```

Optimality gap - Distance between greatest lower bound and best solution -  equal to zero when optimal solution has been reached:
(When UC mode is fast or accurate, this gap can be negative due to the approximations of ANTARES' heuristics. When relaxed UC mode are used, this gap can be slightly negative due to numeric approximations in cuts)
```{r print_optimality_gap, echo=FALSE, eval = TRUE}
cat(subset(x$costs, it == best_solutions[1])$overall_costs - max(x$under_estimator), "euros")
```

Convergence of costs
```{r plot_cost_convergence, echo = FALSE, eval = TRUE, warning = FALSE, message=FALSE}

# prepare data.frame structure for plotly
costs <- x$costs
costs$best_bound  <-  x$under_estimator

min_1_n <- function(n, vect)
{
  if(!all(is.na(vect[1:n])))
  {
    return(min(vect[1:n], na.rm = TRUE))
  }
  else{return(NA)}
}

costs$best_solution_until_now <- sapply(1:n_iteration, min_1_n, vect = x$costs$overall_costs)

# plot (ov_cost, best_bound, best_sol) = f(it)

p <- plot_ly(costs, x = ~it, width = "100%") %>%
  add_trace(y = ~best_solution_until_now, name = 'Best solution until this iteration', mode = 'lines+markers', type = "scatter") %>%
  add_trace(y = ~best_bound, name = 'Lower bound', mode = 'lines+markers', type = "scatter") %>%
  add_trace(x = ~it[!is.na(overall_costs)], y = ~na.omit(overall_costs), name = 'Total cost',mode = 'lines+markers', type = "scatter") %>%
  layout(yaxis = list(title = "(euros)"), legend = list(orientation = 'h'))

p

```



# Details for each iteration

Table - invested capacity at each iteration (in MW) :

```{r table_details, echo = FALSE}


# transpose 

kable(spread(x$invested_capacities[, -2], key = "candidate", value = "value"), format = "markdown")


```

Table - costs a each iteration (in euros) :

```{r table_costs, echo = FALSE}

kable(costs, format = "markdown")

```

Table - Loss of Load Expectation(in hours) :

```{r table_lole, echo = FALSE}

lold_matrix <- sapply(x$digest, FUN = function(it){return(it$LOLD)})
rownames(lold_matrix) <- x$digest$it1$area
kable(t(lold_matrix), format = "markdown")

```

<style type="text/css">
.table {

    width: 40%;

}
</style>